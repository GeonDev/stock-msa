#!/bin/zsh

# ============================================================================
# AI 자동 코드 리뷰 시스템 - Pre-commit Hook (MSA/Multi-Module 최적화 버전)
# ============================================================================

set -e

# 1. 환경 설정 및 경로 초기화
export PATH="$PATH:/usr/local/bin:/opt/homebrew/bin"
source ~/.zshrc 2>/dev/null || true

PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
REPORT_FILE="$PROJECT_ROOT/GEMINI_REPORT.md"
TMP_MSG_FILE="$PROJECT_ROOT/.git/GEMINI_MSG_TMP"

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

echo "${CYAN}============================================${NC}"
echo "${CYAN}🤖 MSA 아키텍트 제미나이 코드 리뷰 시작${NC}"
echo "${CYAN}============================================${NC}"

# 2. 리포트 파일 초기화
rm -f "$REPORT_FILE" "$TMP_MSG_FILE"
touch "$REPORT_FILE"
chmod 666 "$REPORT_FILE" 2>/dev/null || true

# 3. 분석 대상 파일 필터링
VALID_EXTENSIONS="java|sql|xml|html|ftl|properties|yml|yaml"
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -E "\.($VALID_EXTENSIONS)$" || true)

if [[ -z "$STAGED_FILES" ]]; then
    echo "${GREEN}[PASS] 분석 대상 파일 없음 - 커밋 진행${NC}"
    exit 0
fi

# 4. 분석 데이터 구성 (멀티 모듈 컨텍스트 포함)
CLEAN_INPUT="당신은 MSA 및 Spring Boot 멀티 모듈 아키텍처 전문가입니다.
현재 프로젝트 'stock-msa'는 corp, finance, stock 도메인으로 분리된 마이크로서비스 구조입니다.

[중요 지침]
- 각 파일은 전체 경로를 포함하고 있으므로, 어느 서비스의 코드인지 명확히 구분하여 분석하세요.
- 도메인 간 통신(RestClient/DTO)과 DB 분리 원칙이 잘 지켜지고 있는지 중점적으로 확인하세요.
- 코드를 제안할 때 경로 식별자(F1, F2 등)를 코드 블록 내부에 포함하지 마세요.

[분석 대상 코드]\n\n"

MAPPING_INFO=""
FILE_COUNTER=1
TOTAL_LINES=0

while IFS= read -r file; do
    if [[ ! -f "$PROJECT_ROOT/$file" ]]; then continue; fi

    # 환각 방지: 추가된 라인만 추출하되 전체 경로를 헤더로 사용
    CODE=$(git diff --cached -- "$file" | grep '^+' | grep -v '^+++' | sed 's/^+//')

    if [[ -n "$CODE" ]]; then
        FILE_ID="F${FILE_COUNTER}"
        LINE_COUNT=$(echo "$CODE" | wc -l | xargs)

        CLEAN_INPUT+="[${FILE_ID}: ${file}]\n"
        CLEAN_INPUT+="CODE_START\n"
        CLEAN_INPUT+="\"\"\"\n${CODE}\n\"\"\"\n"
        CLEAN_INPUT+="CODE_END\n\n"

        MAPPING_INFO+="- **${FILE_ID}**: \
	\`${file}\` (${LINE_COUNT} 라인)\n"
        ((FILE_COUNTER++))
        ((TOTAL_LINES+=LINE_COUNT))
    fi
done <<< "$STAGED_FILES"

# 5. AI 분석 요청
echo "${BLUE}[INFO] 총 ${TOTAL_LINES} 라인 분석 중...${NC}"

AI_PROMPT="${CLEAN_INPUT}

[분석 요청사항]
1. 치명적 결함(보안, NPE, 로직 오류) 발견 시에만 [BLOCK] 키워드를 사용하세요.
2. YAML/Properties 파일은 도메인별로 설정이 중복될 수 있으므로 절대 [BLOCK] 하지 마세요.
3. 다음 태그를 포함하여 응답하세요:
   [PASS]
   [PROJECT_IMPACT]: 전체 시스템 영향 (멀티 모듈 의존성 등)
   [SIDE_EFFECTS]: 부작용 리스크
   [CLEAN_CODE]: 리팩토링 제안 (Spring Boot/MSA 관점)
   [PERFORMANCE]: 최적화 제안
   [COMPLEXITY]: 복잡도 (1~10)
   [TEST_GUIDE]: 필수 테스트 시나리오
   [COMMIT_MSG]: 커밋 메시지 (한글로만, 접두사 제외)"

AI_RESPONSE=$(echo "$AI_PROMPT" | gemini 2>&1 || echo "ERROR")

# 6. 응답 정제 (CLI 초기화 로그 제거)
CLEANED_RESPONSE=$(echo "$AI_RESPONSE" | \
    grep -v "Loaded cached credentials" | \
    grep -v "supports tool updates" | \
    grep -v "supports resource updates" | \
    grep -v "Hook registry initialized" | \
    grep -v "DeprecationWarning" | \
    sed 's/\*\*//g' | \
    sed 's/```[a-z]*//g' | \
    sed 's/```//g')

# 7. 섹션 파싱 함수
parse_section() {
    local tag="$1"
    echo "$CLEANED_RESPONSE" | sed -n "/${tag}/,/\\[/p" | grep -v "\[" | xargs || echo "정보 없음"
}

# 8. 리포트 생성 및 결과 처리
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

{
    echo "# 🤖 Gemini MSA 코드 리뷰 리포트"
    echo ""
    echo "> **분석 일시:** $(date '+%Y-%m-%d %H:%M:%S')"
    echo "> **브랜치:** \
	\`${CURRENT_BRANCH}\`"
    echo ""
    echo "## 📂 분석 대상 파일"
    echo -e "$MAPPING_INFO"
    echo "---"
} > "$REPORT_FILE"

if echo "$CLEANED_RESPONSE" | grep -qi '[[BLOCK]]'; then
    BLOCK_REASON=$(echo "$CLEANED_RESPONSE" | grep -i '[[BLOCK]]' | head -1)
    echo "${RED}🚨 [BLOCK] 커밋 거부: ${BLOCK_REASON}${NC}"
    echo "### 🚨 커밋 거부 사유\n\n${BLOCK_REASON}\n\n#### 상세 분석\n${CLEANED_RESPONSE}" >> "$REPORT_FILE"
    exit 1
else
    echo "${GREEN}✅ [PASS] 코드 리뷰 통과!${NC}"
    
    IMPACT=$(parse_section "[PROJECT_IMPACT]")
    SIDE_EFFECTS=$(parse_section "[SIDE_EFFECTS]")
    CLEAN_CODE=$(parse_section "[CLEAN_CODE]")
    COMMIT_MSG=$(parse_section "[COMMIT_MSG]")

    {
        echo "### 🔍 1. 영향도 분석\n${IMPACT}\n"
        echo "### ⚠️ 2. 사이드 이펙트\n${SIDE_EFFECTS}\n"
        echo "### ✨ 3. 클린 코드 제안\n${CLEAN_CODE}\n"
        echo "---"
        echo "## 💬 추천 커밋 메시지\n\
	\
	\`${COMMIT_MSG}\`"
    } >> "$REPORT_FILE"

    echo "$COMMIT_MSG" > "$TMP_MSG_FILE"
    echo "${GREEN}📄 리포트 저장 완료: ${REPORT_FILE}${NC}"
    exit 0
fi