#!/bin/zsh

# ============================================================================
# AI 자동 코드 리뷰 시스템 - Pre-commit Hook (통합 최적화 버전)
# ============================================================================
# 제작: Claude + Gemini 버전 통합
# 특징: 환각 방지, 에러 핸들링, 상세 리포트, 안정성 강화
# ============================================================================

set -e  # 에러 발생 시 즉시 종료

# ============================================================================
# 1. 환경 설정 및 경로 초기화
# ============================================================================

# PATH 환경 변수 확장 (Homebrew, 로컬 bin 등)
export PATH="$PATH:/usr/local/bin:/opt/homebrew/bin"
source ~/.zshrc 2>/dev/null || true

# Git 루트 디렉토리 절대 경로 획득 (실패 시 현재 디렉토리)
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
REPORT_FILE="$PROJECT_ROOT/GEMINI_REPORT.md"
TMP_MSG_FILE="$PROJECT_ROOT/.git/GEMINI_MSG_TMP"

# 색상 정의 (터미널 출력용)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 디버깅 정보 출력
echo "${CYAN}============================================${NC}"
echo "${CYAN}🤖 시니어 아키텍트 제미나이 코드 리뷰 시작${NC}"
echo "${CYAN}============================================${NC}"
echo "${BLUE}📂 프로젝트 루트: ${PROJECT_ROOT}${NC}"
echo "${BLUE}📄 리포트 경로: ${REPORT_FILE}${NC}"

# ============================================================================
# 2. 리포트 파일 초기화 (권한 확보)
# ============================================================================

rm -f "$REPORT_FILE" "$TMP_MSG_FILE"
touch "$REPORT_FILE"
chmod 666 "$REPORT_FILE" 2>/dev/null || true

if [ ! -w "$REPORT_FILE" ]; then
    echo "${RED}❌ [오류] 리포트 파일 쓰기 권한 없음${NC}"
    echo "${YELLOW}[경고] 리뷰는 계속 진행되지만 리포트는 생성되지 않습니다${NC}"
fi

# ============================================================================
# 3. .DS_Store 자동 제거
# ============================================================================

DS_STORE_FILES=$(git diff --cached --name-only | grep '\.DS_Store$' || true)
if [[ -n "$DS_STORE_FILES" ]]; then
    echo "${YELLOW}[INFO] .DS_Store 파일 감지 - 자동 제거 중...${NC}"
    echo "$DS_STORE_FILES" | xargs git reset HEAD > /dev/null 2>&1 || true
fi

# ============================================================================
# 4. 분석 대상 파일 필터링 (삭제 파일 절대 제외)
# ============================================================================

VALID_EXTENSIONS="java|sql|xml|html|ftl|properties|yml|yaml"

# CRITICAL: --diff-filter=ACMR (Deleted 제외)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | \
    grep -E "\.($VALID_EXTENSIONS)$" || true)

if [[ -z "$STAGED_FILES" ]]; then
    echo "${GREEN}[PASS] 분석 대상 파일 없음 - 커밋 진행${NC}"
    exit 0
fi

echo "${BLUE}[INFO] 분석 대상 파일 (총 $(echo "$STAGED_FILES" | wc -l | xargs)개):${NC}"
echo "$STAGED_FILES" | sed 's/^/  ✓ /'
echo ""

# ============================================================================
# 5. 순수 코드 추출 (Git 메타데이터 제거 - 환각 방지 핵심)
# ============================================================================

CLEAN_INPUT="당신은 시니어 백엔드 개발자이자 코드 리뷰 전문가입니다.
Java/Spring 프레임워크, 시스템 아키텍처, 성능 최적화에 깊은 전문성을 가지고 있습니다.

[중요 지침]
- 아래는 Git diff에서 추출한 순수 코드 변경 사항입니다.
- 파일 식별자([F1: ...])는 오직 구분용이며, 분석 결과 보고 시에만 사용하세요.
- **[경고]** [CLEAN_CODE] 섹션에서 코드를 제안할 때, 파일 경로(예: @src/main/...)나 식별자(F1, F2 등)를 코드 블록 내부에 절대 포함하지 마세요. 오직 순수 Java/SQL 코드만 제공해야 합니다.
- 각 코드 블록을 독립적으로 검토하되, 전체 프로젝트 맥락을 고려하세요.

[분석 대상 코드]\n\n"

MAPPING_INFO=""
FILE_COUNTER=1
TOTAL_LINES=0

# 임시 파일 경로를 .git 내부 절대 경로로 설정
TMP_MSG_FILE="$PROJECT_ROOT/.git/GEMINI_MSG_TMP"
rm -f "$TMP_MSG_FILE"

while IFS= read -r file; do
    # [핵심 1] 파일 실제 존재 확인 (Deleted 파일로 인한 Fatal 에러 방지)
    if [[ ! -f "$PROJECT_ROOT/$file" ]]; then
        echo "${YELLOW}[경고] 파일 없음 (스킵): $file${NC}"
        continue
    fi

    FILENAME=$(basename "$file")

    # [핵심 2] 환각 방지 로직 - Git 메타데이터 완벽 제거
    # Step 1: 추가된 라인만 추출 (^+로 시작)
    # Step 2: Git 헤더 제거 (^+++로 시작하는 라인 제외)
    # Step 3: + 기호 제거
    CODE=$(git diff --cached -- "$file" | \
        grep '^+' | \
        grep -v '^+++' | \
        sed 's/^+//')

    if [[ -n "$CODE" ]]; then
        FILE_ID="F${FILE_COUNTER}"
        LINE_COUNT=$(echo "$CODE" | wc -l | xargs)

        # 구조화된 코드 블록 생성
        CLEAN_INPUT+="[${FILE_ID}: ${FILENAME}]\n"
        CLEAN_INPUT+="CODE_START\n"
        CLEAN_INPUT+="\"\"\"\n${CODE}\n\"\"\"\n"
        CLEAN_INPUT+="CODE_END\n\n"

        # 매핑 정보 저장 (리포트용)
        MAPPING_INFO+="- **${FILE_ID}**: \`${file}\` (${FILENAME}) - ${LINE_COUNT} 라인\n"

        ((FILE_COUNTER++))
        ((TOTAL_LINES+=LINE_COUNT))
    fi
done <<< "$STAGED_FILES"

if [[ -z "$MAPPING_INFO" ]]; then
    echo "${GREEN}[PASS] 추가된 코드 없음 - 커밋 진행${NC}"
    exit 0
fi

echo "${BLUE}[INFO] 총 ${FILE_COUNTER} 개 파일, ${TOTAL_LINES} 라인 분석 시작...${NC}"

# ============================================================================
# 6. AI 프롬프트 구성 및 요청 (타임아웃 적용)
# ============================================================================

AI_PROMPT="${CLEAN_INPUT}

[분석 요청사항]
다음 관점에서 코드를 검토하고, 아래 태그 형식으로 응답하세요:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 절대 규칙: YAML/Properties 파일은 절대 [BLOCK] 금지!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

application.yaml, application.yml, *.properties 파일에 대해서는:
- 절대로 [BLOCK] 키워드를 사용하지 마세요
- 문제가 있다고 판단되면 [CLEAN_CODE] 섹션에 개선 제안만 작성하세요
- 이유: YAML은 계층 구조가 복잡하여 오판 가능성이 매우 높음

예시:
- datasource-meta와 datasource-data는 다른 키입니다 (중복 아님)
- --- 구분자는 프로필 분리입니다 (중복 아님)
- jdbc-url이 여러 곳에 있어도 부모가 다르면 정상입니다

[BLOCK]은 오직 Java/SQL 코드에서만:
- SQL 인젝션, XSS 취약점
- NullPointerException 유발 코드
- 명백한 로직 오류 (무한루프, 잘못된 조건문)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. **치명적 결함 발견 시** (Java/SQL 파일만):
   - 반드시 응답 첫 줄에 '[BLOCK]' 키워드를 포함하세요
   - 형식: [BLOCK] [클래스명 또는 파일ID]: 구체적인 이유
   - 예시: [BLOCK] [F1-UserService]: SQL 인젝션 취약점 발견
   - 주의: YAML/Properties 파일은 절대 [BLOCK] 금지!

2. **정상 코드인 경우**:
   아래 태그를 사용하여 각 섹션별로 분석하세요 (마크다운 ** 기호 사용 금지):

   [PASS]
   [PROJECT_IMPACT]: 이 변경이 전체 시스템에 미치는 영향 분석 (DB 스키마, API 호환성 등)
   [SIDE_EFFECTS]: 예상되는 부작용 및 리스크 (트랜잭션, 동시성, 메모리 등)
   [CLEAN_CODE]: 클린 코드 및 리팩토링 제안 (Google Java Style Guide(https://google.github.io/styleguide/javaguide.html)를 참고하여 네이밍, 중복 코드, SOLID 원칙, YAML 경고 등)
   [PERFORMANCE]: 성능 최적화 가능성 (DB 쿼리, N+1 문제, 인덱스, 캐싱 등)
   [COMPLEXITY]: 코드 복잡도 점수 (1~10점) 및 이유
   [TEST_GUIDE]: 필수 테스트 시나리오 제안 (단위 테스트, 통합 테스트)
   [COMMIT_MSG]: 커밋 메시지 제안 (순수 한글로만, feat/fix/refactor 같은 영문 접두사 제외, JIRA ID 제외, 간결하게)

[응답 규칙]
- 모든 응답은 한글로 작성
- 각 섹션은 간결하고 핵심적인 내용만 포함
- 마크다운 ** 기호는 절대 사용하지 말 것
- 태그는 반드시 대괄호 [] 안에 작성
- YAML/Properties 파일은 절대 [BLOCK] 금지!"

# AI 요청 실행 (에러 핸들링 적용)
echo "${CYAN}[AI] Gemini 분석 중...${NC}"

AI_RESPONSE=""
AI_ERROR=0

# Gemini API 호출 (일반적으로 10-30초 내 응답)
if ! AI_RESPONSE=$(echo "$AI_PROMPT" | gemini 2>&1); then
    AI_ERROR=1
fi

# AI 응답 검증
if [[ $AI_ERROR -eq 1 ]] || [[ -z "$AI_RESPONSE" ]] || [[ "$AI_RESPONSE" == *"error"* ]]; then
    echo "${RED}[ERROR] AI 서비스 응답 실패${NC}"
    echo "${YELLOW}[경고] 코드 리뷰 없이 커밋을 진행합니다${NC}"

    # 실패 리포트 작성
    {
        echo "# 🤖 Gemini 시니어 코드 리뷰 리포트"
        echo ""
        echo "> **분석 일시:** $(date '+%Y-%m-%d %H:%M:%S')"
        echo "> **상태:** ⚠️ AI 응답 실패"
        echo ""
        echo "## 📂 분석 대상 파일"
        echo -e "$MAPPING_INFO"
        echo ""
        echo "---"
        echo ""
        echo "### ⚠️ AI 분석 실패"
        echo "Gemini API가 응답하지 않아 코드 리뷰를 수행할 수 없습니다."
        echo "커밋은 정상적으로 진행되지만, 수동 코드 리뷰를 권장합니다."
        echo ""
        echo "**에러 내용:**"
        echo "\`\`\`"
        echo "$AI_RESPONSE"
        echo "\`\`\`"
    } > "$REPORT_FILE"

    exit 0
fi

echo "${GREEN}[AI] 분석 완료!${NC}"

# ============================================================================
# 7. AI 응답 파싱 (섹션별 추출 함수)
# ============================================================================

# 마크다운 제거 및 정리
CLEANED_RESPONSE=$(echo "$AI_RESPONSE" | \
    sed 's/```[a-z]*//g' | \
    sed 's/```//g' | \
    sed 's/\*\*//g' | \
    grep -v "Loaded cached credentials" || echo "$AI_RESPONSE")

# 섹션 파싱 함수 (개선된 버전)
parse_section() {
    local tag="$1"
    local result=""

    # 태그 다음 라인부터 다음 태그 전까지 추출
    result=$(echo "$CLEANED_RESPONSE" | \
        sed -n "/${tag}/,/\[/p" | \
        grep -v "\[" | \
        sed 's/^[*-] //g' | \
        xargs || echo "")

    # 결과가 비어있으면 기본값 반환
    if [[ -z "$result" ]]; then
        echo "정보 없음"
    else
        echo "$result"
    fi
}

# ============================================================================
# 8. 리포트 파일 생성
# ============================================================================

# 현재 브랜치 및 JIRA ID 추출
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
JIRA_ID=$(echo "$CURRENT_BRANCH" | grep -oE '[A-Z]+-[0-9]+' | head -1 || echo "")

# 리포트 헤더 작성
{
    echo "# 🤖 Gemini 시니어 코드 리뷰 리포트"
    echo ""
    echo "> **분석 일시:** $(date '+%Y-%m-%d %H:%M:%S')"
    echo "> **브랜치:** \`${CURRENT_BRANCH}\`"
    echo "> **분석 파일 수:** ${FILE_COUNTER} 개"
    echo "> **총 변경 라인:** ${TOTAL_LINES} 라인"
    if [[ -n "$JIRA_ID" ]]; then
        echo "> **JIRA 티켓:** ${JIRA_ID}"
    fi
    echo ""
    echo "## 📂 분석 대상 파일"
    echo -e "$MAPPING_INFO"
    echo ""
    echo "---"
    echo ""
} > "$REPORT_FILE"

# ============================================================================
# 9. 블록 여부 판단 및 결과 처리
# ============================================================================

if echo "$CLEANED_RESPONSE" | grep -qi '\[BLOCK\]'; then
    # ========== 커밋 거부 시나리오 ==========
    echo "${RED}============================================${NC}"
    echo "${RED}🚨 [BLOCK] 커밋 거부!${NC}"
    echo "${RED}============================================${NC}"

    # 거부 사유 추출
    BLOCK_REASON=$(echo "$CLEANED_RESPONSE" | grep -i '\[BLOCK\]' | head -1)

    echo "${RED}제미나이가 심각한 이슈를 감지했습니다:${NC}"
    echo "${YELLOW}${BLOCK_REASON}${NC}"
    echo ""
    echo "${BLUE}📄 상세 리포트: ${REPORT_FILE}${NC}"
    echo "${RED}============================================${NC}"

    # 에러 리포트 작성
    {
        echo "### 🚨 커밋 거부 사유"
        echo ""
        echo "제미나이가 다음과 같은 치명적 결함을 발견하여 커밋을 차단했습니다:"
        echo ""
        echo "#### 발견된 문제"
        echo "\`\`\`"
        echo "$BLOCK_REASON"
        echo "\`\`\`"
        echo ""
        echo "#### 전체 분석 내용"
        echo "$CLEANED_RESPONSE"
        echo ""
        echo "---"
        echo ""
        echo "**조치 방법:**"
        echo "1. 위에서 지적된 문제를 수정하세요"
        echo "2. 수정 후 다시 커밋을 시도하세요"
        echo "3. 문제가 계속되면 시니어 개발자에게 코드 리뷰를 요청하세요"
    } >> "$REPORT_FILE"

    exit 1

else
    # ========== 커밋 승인 시나리오 ==========
    echo "${GREEN}============================================${NC}"
    echo "${GREEN}✅ [PASS] 코드 리뷰 통과!${NC}"
    echo "${GREEN}============================================${NC}"

    # 각 섹션 파싱
    IMPACT=$(parse_section "\[PROJECT_IMPACT\]")
    SIDE_EFFECTS=$(parse_section "\[SIDE_EFFECTS\]")
    CLEAN_CODE=$(parse_section "\[CLEAN_CODE\]")
    PERFORMANCE=$(parse_section "\[PERFORMANCE\]")
    COMPLEXITY=$(parse_section "\[COMPLEXITY\]")
    TEST_GUIDE=$(parse_section "\[TEST_GUIDE\]")
    COMMIT_MSG=$(parse_section "\[COMMIT_MSG\]")

    # 상세 리포트 작성
    {
        echo "### 🔍 1. 프로젝트 영향도 분석 (Project Impact)"
        echo ""
        echo "${IMPACT}"
        echo ""
        echo "### ⚠️ 2. 예상되는 사이드 이펙트 (Side Effects)"
        echo ""
        echo "${SIDE_EFFECTS}"
        echo ""
        echo "### ✨ 3. 클린 코드 관점 리뷰 (Clean Code)"
        echo ""
        echo "${CLEAN_CODE}"
        echo ""
        echo "### ⚡ 4. 성능 최적화 (Performance & Optimization)"
        echo ""
        echo "${PERFORMANCE}"
        echo ""
        echo "### 📊 5. 코드 복잡도 (Complexity Score)"
        echo ""
        echo "**점수:** ${COMPLEXITY}"
        echo ""
        echo "### 🧪 6. 추천 테스트 시나리오 (Test Guide)"
        echo ""
        echo "${TEST_GUIDE}"
        echo ""
        echo "---"
        echo ""
        echo "## 💬 추천 커밋 메시지"
        echo ""
    } >> "$REPORT_FILE"

    # JIRA ID 결합한 최종 커밋 메시지 생성
    if [[ -z "$COMMIT_MSG" ]] || [[ "$COMMIT_MSG" == "정보 없음" ]]; then
        COMMIT_MSG="코드 개선"
    fi

    if [[ -n "$JIRA_ID" ]]; then
        FINAL_MSG="$JIRA_ID $COMMIT_MSG"
    else
        FINAL_MSG="$COMMIT_MSG"
    fi

    # 커밋 메시지 리포트에 추가
    {
        echo "\`\`\`"
        echo "$FINAL_MSG"
        echo "\`\`\`"
        echo ""
        echo "---"
        echo ""
        echo "✅ **모든 검토를 통과하여 커밋이 승인되었습니다.**"
        echo ""
        echo "*Generated by Gemini AI Code Review System v2.0*"
    } >> "$REPORT_FILE"

    # 임시 커밋 메시지 파일 저장
    echo "$FINAL_MSG" > "$TMP_MSG_FILE"
    chmod 666 "$TMP_MSG_FILE" 2>/dev/null || true

    # 터미널 출력
    echo "${GREEN}📄 리포트 저장 완료: ${REPORT_FILE}${NC}"
    echo "${GREEN}💬 추천 커밋 메시지:${NC}"
    echo "${CYAN}   ${FINAL_MSG}${NC}"
    echo ""
    echo "${BLUE}[TIP] 리포트 파일을 열어 상세 분석 내용을 확인하세요${NC}"
    echo "${GREEN}============================================${NC}"

    exit 0
fi
