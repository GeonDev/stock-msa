#!/bin/zsh

# ============================================================================
# AI 자동 코드 리뷰 시스템 - Pre-commit Hook (MSA/Multi-Module 최적화 버전)
# ============================================================================

set -e

# 1. 환경 설정 및 경로 초기화
export PATH="$PATH:/usr/local/bin:/opt/homebrew/bin"
source ~/.zshrc 2>/dev/null || true

PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

# 1.1 .env 파일 로드 (GEMINI_API_KEY 등 환경 변수 주입)
if [ -f "$PROJECT_ROOT/.env" ]; then
    # 주석(#)이 아닌 라인들만 추출하여 export
    while IFS= read -r line || [ -n "$line" ]; do
        [[ $line =~ ^#.* ]] && continue
        [[ $line =~ ^[[:space:]]*$ ]] && continue
        export "$line"
    done < "$PROJECT_ROOT/.env"
fi

REPORT_FILE="$PROJECT_ROOT/GEMINI_REPORT.md"
TMP_MSG_FILE="$PROJECT_ROOT/.git/GEMINI_MSG_TMP"

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

echo "${CYAN}============================================${NC}"
echo "${CYAN}🤖 MSA 아키텍트 제미나이 코드 리뷰 시작${NC}"
echo "${CYAN}============================================${NC}"

# 2. 리포트 파일 초기화
rm -f "$REPORT_FILE" "$TMP_MSG_FILE"
touch "$REPORT_FILE"
chmod 666 "$REPORT_FILE" 2>/dev/null || true

# 3. 분석 대상 파일 필터링
VALID_EXTENSIONS="java|sql|xml|html|ftl|properties|yml|yaml"
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -E "\.($VALID_EXTENSIONS)$" || true)

if [[ -z "$STAGED_FILES" ]]; then
    echo "${GREEN}[PASS] 분석 대상 파일 없음 - 커밋 진행${NC}"
    exit 0
fi

# 4. 분석 데이터 구성 (멀티 모듈 컨텍스트 포함)
CLEAN_INPUT="당신은 MSA 및 Spring Boot 멀티 모듈 아키텍처 전문가입니다.
현재 프로젝트 'stock-msa'는 corp, finance, stock 도메인으로 분리된 마이크로서비스 구조입니다.

[중요 지침]
- 각 파일은 전체 경로와 전체 코드를 포함하고 있습니다.
- 도메인 간 통신(RestClient/DTO)과 DB 분리 원칙이 잘 지켜지고 있는지 중점적으로 확인하세요.
- **환각 방지**: 문법 오류나 컴파일 오류를 지적할 때는 반드시 해당 라인이 코드 내에 존재하는지 재확인하세요. 확실하지 않은 경우 지적하지 마세요.
- 코드를 제안할 때 경로 식별자(F1, F2 등)를 코드 블록 내부에 포함하지 마세요.

[분석 대상 코드]\n\n"

MAPPING_INFO=""
FILE_COUNTER=1
TOTAL_LINES=0

while IFS= read -r file; do
    if [[ ! -f "$PROJECT_ROOT/$file" ]]; then continue; fi

    # [개선] 추가된 라인만 보내면 컨텍스트 부족으로 환각(Hallucination)이 발생함.
    # 스테이징된 파일의 전체 내용을 전달하여 정확한 분석 유도.
    CODE=$(git show ":$file")

    if [[ -n "$CODE" ]]; then
        FILE_ID="F${FILE_COUNTER}"
        LINE_COUNT=$(echo "$CODE" | wc -l | xargs)

        CLEAN_INPUT+="[${FILE_ID}: ${file}]\n"
        CLEAN_INPUT+="CODE_START\n"
        CLEAN_INPUT+="\"\"\"\n${CODE}\n\"\"\"\n"
        CLEAN_INPUT+="CODE_END\n\n"

        MAPPING_INFO+="- **${FILE_ID}**: \
	\`${file}\` (${LINE_COUNT} 라인)\n"
        ((FILE_COUNTER++))
        ((TOTAL_LINES+=LINE_COUNT))
    fi
done <<< "$STAGED_FILES"

# 5. AI 분석 요청
echo "${BLUE}[INFO] 총 ${TOTAL_LINES} 라인 분석 중...${NC}"

AI_PROMPT="${CLEAN_INPUT}

[분석 요청사항]
1. 다음의 경우 반드시 [BLOCK] 키워드를 사용하여 커밋을 차단하세요:
   - 보안 취약점 (API 키 노출 등)
   - 치명적인 로직 오류 (NPE 등)
   - YAML/Properties 설정 파일의 문법 오류, 잘못된 들여쓰기, 필수 값 누락, 유효하지 않은 URL 포맷

2. 다음 태그를 사용하여 구조화된 리포트를 작성하세요:
   [BLOCK] (차단 시 사유 작성)
   [PASS] (통과 시)
   [PROJECT_IMPACT]
   [SIDE_EFFECTS]
   [CLEAN_CODE]
   [PERFORMANCE]
   [TEST_GUIDE]
   [COMMIT_MSG] (한글로 작성, 50자 이내 요약 + 본문)"

AI_RESPONSE=$(echo "$AI_PROMPT" | gemini 2>&1 || echo "ERROR")

# 6. 응답 정제 (CLI 초기화 로그 제거)
CLEANED_RESPONSE=$(echo "$AI_RESPONSE" | \
    grep -v "Loaded cached credentials" | \
    grep -v "supports tool updates" | \
    grep -v "supports resource updates" | \
    grep -v "Hook registry initialized" | \
    grep -v "DeprecationWarning" | \
    sed 's/\*\*//g' | \
    sed 's/```[a-z]*//g' | \
    sed 's/```//g')

# 7. 섹션 파싱 함수
parse_section() {
    local tag="$1"
    echo "$CLEANED_RESPONSE" | sed -n "/${tag}/,/\\[/p" | grep -v "\[" | xargs || echo "정보 없음"
}

# 8. 리포트 생성 및 결과 처리
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

{
    echo "# 🤖 Gemini MSA 코드 리뷰 리포트"
    echo ""
    echo "> **분석 일시:** $(date '+%Y-%m-%d %H:%M:%S')"
    echo "> **브랜치:** \
	\`${CURRENT_BRANCH}\`"
    echo ""
    echo "## 📂 분석 대상 파일"
    echo -e "$MAPPING_INFO"
    echo "---"
} > "$REPORT_FILE"

if echo "$CLEANED_RESPONSE" | grep -qi '\[BLOCK\]'; then
    # [BLOCK] 태그 이후의 내용을 추출하여 사유로 사용
    BLOCK_REASON=$(echo "$CLEANED_RESPONSE" | sed -n '/\[BLOCK\]/,/\[/p' | grep -v "\\[" | sed 's/\[BLOCK\]//g' | xargs)
    
    echo "${RED}🚨 [BLOCK] 커밋 거부${NC}"
    echo "${RED}사유: ${BLOCK_REASON}${NC}"
    
    echo "### 🚨 커밋 거부 사유" >> "$REPORT_FILE"
    echo "> ${BLOCK_REASON}" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "#### 📝 상세 분석" >> "$REPORT_FILE"
    echo "${CLEANED_RESPONSE}" >> "$REPORT_FILE"
    
    exit 1
else
    echo "${GREEN}✅ [PASS] 코드 리뷰 통과!${NC}"
    
    IMPACT=$(parse_section "[PROJECT_IMPACT]")
    SIDE_EFFECTS=$(parse_section "[SIDE_EFFECTS]")
    CLEAN_CODE=$(parse_section "[CLEAN_CODE]")
    COMMIT_MSG=$(parse_section "[COMMIT_MSG]")

    {
        echo "### 🔍 1. 영향도 분석\n${IMPACT}\n"
        echo "### ⚠️ 2. 사이드 이펙트\n${SIDE_EFFECTS}\n"
        echo "### ✨ 3. 클린 코드 제안\n${CLEAN_CODE}\n"
        echo "---"
        echo "## 💬 추천 커밋 메시지\n\
	\
	\`${COMMIT_MSG}\`"
    } >> "$REPORT_FILE"

    echo "$COMMIT_MSG" > "$TMP_MSG_FILE"
    echo "${GREEN}📄 리포트 저장 완료: ${REPORT_FILE}${NC}"
    exit 0
fi